/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "i2c.h"
#include "tim.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "math.h"
#include "MPU6050.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */


// MPU6050 values
int16_t ax, ay, az, gx, gy, gz, tmpr;

float baseAcc_x = 0;
float baseAcc_y = 0;
float baseAcc_z = 0;
float baseGyro_x = 0;
float baseGyro_y = 0;
float baseGyro_z = 0;

float accel_x = 0;
float accel_y = 0;
float accel_z = 0;

float accel_xz = 0;
float accel_yz = 0;

float accel_angle_x = 0;
float accel_angle_y = 0;
float accel_angle_z = 0;

float gyro_x = 0;
float gyro_y = 0;
float gyro_z = 0;

float gyro_angle_x = 0;
float gyro_angle_y = 0;
float gyro_angle_z = 0;

float tmp_angle_x = 0;
float tmp_angle_y = 0;
float tmp_angle_z = 0;

float dt = 0.001;

float filtered_angle_x = 0;
float filtered_angle_y = 0;
float filtered_angle_z = 0;

#define HEIGHT 32
#define WIDTH 64

#define DotMatrix_EN_1    GPIOA -> BSRR = GPIO_PIN_12;
#define DotMatrix_EN_0    GPIOA -> BRR = GPIO_PIN_12;
#define DotMatrix_LATCH_1 GPIOA -> BSRR = GPIO_PIN_11;
#define DotMatrix_LATCH_0 GPIOA -> BRR = GPIO_PIN_11;
#define DotMatrix_CLK_1   GPIOA -> BSRR = GPIO_PIN_10;
#define DotMatrix_CLK_0   GPIOA -> BRR = GPIO_PIN_10;

#define DotMatrix_A_1   GPIOA -> BSRR = GPIO_PIN_6;
#define DotMatrix_A_0   GPIOA -> BRR = GPIO_PIN_6;
#define DotMatrix_B_1   GPIOA -> BSRR = GPIO_PIN_7;
#define DotMatrix_B_0   GPIOA -> BRR = GPIO_PIN_7;
#define DotMatrix_C_1   GPIOA -> BSRR = GPIO_PIN_8;
#define DotMatrix_C_0   GPIOA -> BRR = GPIO_PIN_8;
#define DotMatrix_D_1   GPIOA -> BSRR = GPIO_PIN_9;
#define DotMatrix_D_0   GPIOA -> BRR = GPIO_PIN_9;

#define DotMatrix_Color_R1_0   GPIOA -> BRR = GPIO_PIN_0;
#define DotMatrix_Color_R1_1   GPIOA -> BSRR = GPIO_PIN_0;

#define DotMatrix_Color_G1_0   GPIOA -> BRR = GPIO_PIN_1;
#define DotMatrix_Color_G1_1   GPIOA -> BSRR = GPIO_PIN_1;

#define DotMatrix_Color_B1_0   GPIOA -> BRR = GPIO_PIN_2;
#define DotMatrix_Color_B1_1   GPIOA -> BSRR = GPIO_PIN_2;

#define DotMatrix_Color_R2_0   GPIOA -> BRR = GPIO_PIN_3;
#define DotMatrix_Color_R2_1   GPIOA -> BSRR = GPIO_PIN_3;

#define DotMatrix_Color_G2_0   GPIOA -> BRR = GPIO_PIN_4;
#define DotMatrix_Color_G2_1   GPIOA -> BSRR = GPIO_PIN_4;

#define DotMatrix_Color_B2_0   GPIOA -> BRR = GPIO_PIN_5;
#define DotMatrix_Color_B2_1   GPIOA -> BSRR = GPIO_PIN_5;

typedef struct {
	uint8_t x;
	uint8_t y;
}Pos;

// 발판 구현
#define LENGTH_TRAM 16
volatile Pos posTram = {62,0};
volatile Pos offsetTram[16] = {{0,0},{1,0},{0,1},{1,1},{0,2},{1,2},{0,3},{1,3},{0,4},{1,4},{0,5},{1,5},{0,6},{1,6},{0,7},{1,7}};

// 벽돌 구현, 긴벽돌
#define LENGTH_BRICK1 14
#define COUNT_BRICK1 9
volatile Pos offsetBrick1[LENGTH_BRICK1] = {{0,0},{1,0},{0,1},{1,1},{0,2},{1,2},{0,3},{1,3},{0,4},{1,4},{0,5},{1,5},{0,6},{1,6}};
volatile Pos posBrick1[COUNT_BRICK1] = {{12,2},{12,12},{12,22},{24,2},{24,12},{24,22},{36,2},{36,12},{36,22}};
volatile int flagBrick1[COUNT_BRICK1] = {1,1,1,1,1,1,1,1,1};


// 벽돌 구현, 짧은 벽돌
#define LENGTH_BRICK2 10
#define COUNT_BRICK2 12
volatile Pos offsetBrick2[LENGTH_BRICK2] = {{0,0},{1,0},{0,1},{1,1},{0,2},{1,2},{0,3},{1,3},{0,4},{1,4}};
volatile Pos posBrick2[COUNT_BRICK2] = {{6,1},{6,9},{6,17},{6,25},{18,1},{18,9},{18,17},{18,25},{30,1},{30,9},{30,17},{30,25}};
volatile int flagBrick2[COUNT_BRICK2] = {1,1,1,1,1,1,1,1,1,1,1,1};

// 공 구현
#define LENGTH_BALL 4
volatile Pos offsetBall[4] = {{0,0},{0,1},{1,0},{1,1}};
volatile Pos posBall = {60,15};
int bYaxisGo = 1;
int bXaxisGo = 1;

// 게임에 사용되는 상수들
#define BASEPRESCALER 48000	// TIM2의 초기 속도
/*
 * 	GAMESTATE
 * 	0 : start page
 * 	1 :	play game
 * 	2 : game over
 * 	3 : game win
 *
 */
int gameState = 0;


// RGB Matrix 1개 좌표 값
typedef struct{
	uint8_t R;
	uint8_t G;
	uint8_t B;
}Color;

// RGB Matrix 색 정의
const Color bk		= {0,0,0};
const Color red		= {1,0,0};
const Color green	= {0,1,0};
const Color blue	= {0,0,1};
const Color purple	= {1,0,1};
const Color yellow	= {1,1,0};

// RGP Matrix 전체
Color Image[32][64] ={
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},

	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},

	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},

	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},

	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},

	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}},
	{{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*1*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*2*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*3*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*4*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*5*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*6*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*7*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*8*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*9*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}/*10*/,{0,0,0},{0,0,0},{0,0,0},{0,0,0}}
};

// 위쪽 절반, 가로 64, 세로 16 범위 색 지정
void setRGB1(Color c)
{
	if(c.R==1){
		DotMatrix_Color_R1_1;
	}
	else{
		DotMatrix_Color_R1_0;
	}

	if(c.G==1){
		DotMatrix_Color_G1_1;
	}
	else {
		DotMatrix_Color_G1_0;
	}

	if(c.B==1){
		DotMatrix_Color_B1_1;
	}
	else {
		DotMatrix_Color_B1_0;
	}
}

// 아래쪽 절반, 가로 64, 세로 16 범위 색 지정
void setRGB2(Color c)
{
	if(c.R==1){
		DotMatrix_Color_R2_1;
	}
	else{
		DotMatrix_Color_R2_0;
	}

	if(c.G==1){
		DotMatrix_Color_G2_1;
	}
	else {
		DotMatrix_Color_G2_0;
	}

	if(c.B==1){
		DotMatrix_Color_B2_1;
	}
	else {
		DotMatrix_Color_B2_0;
	}
}

// ABCD가 각각 한 비트씩 총 16줄 표현
void setABCD(int r){
	   if(r==0){
      DotMatrix_A_0;
      DotMatrix_B_0;
      DotMatrix_C_0;
      DotMatrix_D_0;
   }
   else if(r==1){
      DotMatrix_A_1;
      DotMatrix_B_0;
      DotMatrix_C_0;
      DotMatrix_D_0;
   }
   else if(r==2){
      DotMatrix_A_0;
      DotMatrix_B_1;
      DotMatrix_C_0;
      DotMatrix_D_0;
   }
   else if(r==3){
      DotMatrix_A_1;
      DotMatrix_B_1;
      DotMatrix_C_0;
      DotMatrix_D_0;
   }
   else if(r==4){
      DotMatrix_A_0;
      DotMatrix_B_0;
      DotMatrix_C_1;
      DotMatrix_D_0;
   }
   else if(r==5){
      DotMatrix_A_1;
      DotMatrix_B_0;
      DotMatrix_C_1;
      DotMatrix_D_0;
   }
   else if(r==6){
      DotMatrix_A_0;
      DotMatrix_B_1;
      DotMatrix_C_1;
      DotMatrix_D_0;
   }
   else if(r==7){
      DotMatrix_A_1;
      DotMatrix_B_1;
      DotMatrix_C_1;
      DotMatrix_D_0;
   }
   else if(r==8){
      DotMatrix_A_0;
      DotMatrix_B_0;
      DotMatrix_C_0;
      DotMatrix_D_1;
   }
   else if(r==9){
      DotMatrix_A_1;
      DotMatrix_B_0;
      DotMatrix_C_0;
      DotMatrix_D_1;
   }
   else if(r==10){
      DotMatrix_A_0;
      DotMatrix_B_1;
      DotMatrix_C_0;
      DotMatrix_D_1;
   }
   else if(r==11){
      DotMatrix_A_1;
      DotMatrix_B_1;
      DotMatrix_C_0;
      DotMatrix_D_1;
   }
   else if(r==12){
      DotMatrix_A_0;
      DotMatrix_B_0;
      DotMatrix_C_1;
      DotMatrix_D_1;
   }
   else if(r==13){
      DotMatrix_A_1;
      DotMatrix_B_0;
      DotMatrix_C_1;
      DotMatrix_D_1;
   }
   else if(r==14){
      DotMatrix_A_0;
      DotMatrix_B_1;
      DotMatrix_C_1;
      DotMatrix_D_1;
   }
   else if(r==15){
      DotMatrix_A_1;
      DotMatrix_B_1;
      DotMatrix_C_1;
      DotMatrix_D_1;
   }
}

// LED 보드 전체에 색 값을 쓰고, 출력
void showDisplay()
{
	for(int DotMatrix_y = 0;DotMatrix_y<(HEIGHT/2);DotMatrix_y++)
	{
		// Enable 1이면 설정한 값 출력
		DotMatrix_EN_0;
		// LATCH 0->1 이면  ABCD값 지정하여 줄 넘김
		DotMatrix_LATCH_0;
		for(int DotMatrix_x = 0;DotMatrix_x<WIDTH;DotMatrix_x++)
		{
			// CLK pin이 0->1이면 RGB핀에 값을 읽어 matrix에 쓰고 다음칸 대기
			DotMatrix_CLK_0;
			setRGB1(Image[DotMatrix_y][DotMatrix_x]);
			setRGB2(Image[DotMatrix_y+16][DotMatrix_x]);
			DotMatrix_CLK_1;
		}
		DotMatrix_LATCH_1;
		setABCD(DotMatrix_y);
		DotMatrix_EN_1;
	}
}

// Image 배열 초기화
void clearDisplay()
{
	for (int i = 0; i < HEIGHT; i++)
	{
		for (int j = 0; j < WIDTH; j++)
		{
			Image[i][j] = bk;
		}
	}
}

// 게임 상수 초기화
void initializeGame()
{
	clearDisplay();
	// 공이 초기에 출발하는 방향
	bXaxisGo = 1;
	bYaxisGo = 1;

	// 블럭이 파괴된 여부 초기화
	for	(int i = 0; i < COUNT_BRICK1; i++)
	{
		flagBrick1[i] = 1;
	}
	for	(int i = 0; i < COUNT_BRICK2; i++)
	{
		flagBrick2[i] = 1;
	}

	// 공 위치 초기화
	posBall.x = 60;
	posBall.y = 15;

	// tim2 prescaler 초기화
	TIM2->PSC = BASEPRESCALER;
}

// brick위치, brick을 구성하는 각각의 led의 offset에 따라 Image에 블럭 작성
void drawBrick()
{
	// 긴 블럭 작성
	for (int i = 0; i < COUNT_BRICK1; i++)
	{
		if (flagBrick1[i] == 1)
		{
			for (int j = 0; j < LENGTH_BRICK1; j++)
			{
				Image[posBrick1[i].y + offsetBrick1[j].y][posBrick1[i].x + offsetBrick1[j].x] = green;
			}
		}
		else
		{
			for (int j = 0; j < LENGTH_BRICK1; j++)
			{
				Image[posBrick1[i].y + offsetBrick1[j].y][posBrick1[i].x + offsetBrick1[j].x] = bk;
			}
		}
	}
	// 짧은 블럭 작성
	for (int i = 0; i < COUNT_BRICK2; i++)
	{
		if (flagBrick2[i] == 1)
		{
			for (int j = 0; j < LENGTH_BRICK2; j++)
			{
				Image[posBrick2[i].y + offsetBrick2[j].y][posBrick2[i].x + offsetBrick2[j].x] = red;
			}
		}
		else
		{
			for (int j = 0; j < LENGTH_BRICK2; j++)
			{
				Image[posBrick2[i].y + offsetBrick2[j].y][posBrick2[i].x + offsetBrick2[j].x] = bk;
			}
		}
	}
}

// 공 위치에 따라 Image에 작성
void drawBall()
{
	// erase former ball
	for (int i = 0; i < LENGTH_BALL; i++)
	{
		Image[posBall.y + offsetBall[i].y][posBall.x + offsetBall[i].x] = bk;
	}

	// reflect to right, left
	if (bYaxisGo == 1)	// go right
	{
		posBall.y--;
		if (posBall.y <= 0) bYaxisGo = 0;

		// crush with brick1
		for (int i = 0; i < COUNT_BRICK1; i++)
		{
			if (flagBrick1[i] == 1)
			{
				if ((posBrick1[i].y == posBall.y - (LENGTH_BRICK1 / 2) ) && (posBrick1[i].x + 1 >= posBall.x && posBrick1[i].x - 1 <= posBall.x))
				{
					flagBrick1[i] = 0;
					bYaxisGo = 0;
				}
			}
		}
		// crush with brick2
		for (int i = 0; i < COUNT_BRICK2; i++)
		{
			if (flagBrick2[i] == 1)
			{
				if ((posBrick2[i].y == posBall.y - (LENGTH_BRICK2 / 2) ) && (posBrick2[i].x + 1 >= posBall.x && posBrick2[i].x - 1 <= posBall.x))
				{
					flagBrick2[i] = 0;
					bYaxisGo = 0;
				}
			}
		}
	}
	else if (bYaxisGo == 0)	// go left
	{
		posBall.y++;
		if (posBall.y >= 30) bYaxisGo = 1;

		// crush with brick1
		for (int i = 0; i < COUNT_BRICK1; i++)
		{
			if (flagBrick1[i] == 1)
			{
				if ((posBrick1[i].y == posBall.y + 2 ) && (posBrick1[i].x + 1 >= posBall.x && posBrick1[i].x - 1 <= posBall.x))
				{
					flagBrick1[i] = 0;
					bYaxisGo = 1;
				}
			}
		}

		// crush with brick2
		for (int i = 0; i < COUNT_BRICK2; i++)
		{
			if (flagBrick2[i] == 1)
			{
				if ((posBrick2[i].y == posBall.y + 2 ) && (posBrick2[i].x + 1 >= posBall.x && posBrick2[i].x - 1 <= posBall.x))
				{
					flagBrick2[i] = 0;
					bYaxisGo = 1;
				}
			}
		}
	}

	// reflect to up, down
	if (bXaxisGo == 1)	// go up
	{
		posBall.x--;
		// reflect by roof top
		if (posBall.x <= 0) bXaxisGo = 0;

		// crush with brick1
		for (int i = 0; i < COUNT_BRICK1; i++)
		{
			if (flagBrick1[i] == 1)
			{
				if ((posBrick1[i].x == posBall.x - 2 ) && (posBrick1[i].y + (LENGTH_BRICK1 / 2) >= posBall.y && posBrick1[i].y - 2 <= posBall.y))
				{
					flagBrick1[i] = 0;
					bXaxisGo = 0;
				}
			}
		}
		//crush with brick2
		for (int i = 0; i < COUNT_BRICK2; i++)
		{
			if (flagBrick2[i] == 1)
			{
				if ((posBrick2[i].x == posBall.x - 2 ) && (posBrick2[i].y + (LENGTH_BRICK2 / 2) >= posBall.y && posBrick2[i].y - 2 <= posBall.y))
				{
					flagBrick2[i] = 0;
					bXaxisGo = 0;
				}
			}
		}
	}
	else if (bXaxisGo == 0)	// go down
	{
		posBall.x++;
		if (posBall.x > 61)
		{
			initializeGame();
			gameState = 2;
		}

		//crush with tram
		for (int i = 0; i < LENGTH_TRAM; i++)
		{
			if ((posTram.y + offsetTram[i].y) == posBall.y && (posTram.x + offsetTram[i].x) == posBall.x + 2) bXaxisGo = 1;
			else if ((posTram.y + offsetTram[i].y) == posBall.y + 1 && (posTram.x + offsetTram[i].x) == posBall.x + 2) bXaxisGo = 1;
		}


		//crush with brick1
		for (int i = 0; i < COUNT_BRICK1; i++)
		{
			if (flagBrick1[i] == 1)
			{
				if ((posBrick1[i].x == posBall.x + 2 )&& (posBrick1[i].y + (LENGTH_BRICK1 / 2) >= posBall.y && posBrick1[i].y - 2 <= posBall.y))
				{
					flagBrick1[i] = 0;
					bXaxisGo = 1;
				}
			}
		}

		// crush with brick2
		for (int i = 0; i < COUNT_BRICK2; i++)
		{
			if (flagBrick2[i] == 1)
			{
				if ((posBrick2[i].x == posBall.x + 2 )&& (posBrick2[i].y + (LENGTH_BRICK2 / 2) >= posBall.y && posBrick2[i].y - 2 <= posBall.y))
				{
					flagBrick2[i] = 0;
					bXaxisGo = 1;
				}
			}
		}
	}

	for (int i = 0; i < LENGTH_BALL; i++)
	{
		Image[posBall.y + offsetBall[i].y][posBall.x + offsetBall[i].x] = purple;
	}
}

// 발판 위치 작성
// MPU6050의 값에 따라 위치 달라짐
void drawTram()
{
	for (int i = 0; i < LENGTH_TRAM; i++)
	{
		Image[posTram.y + offsetTram[i].y][posTram.x + offsetTram[i].x] = bk;
	}
	if (filtered_angle_x <-23) posTram.y = 24;
	else if (filtered_angle_x <-21) posTram.y = 23;
	else if (filtered_angle_x <-19) posTram.y = 22;
	else if (filtered_angle_x <-17) posTram.y = 21;
	else if (filtered_angle_x <-15) posTram.y = 20;
	else if (filtered_angle_x <-13) posTram.y = 19;
	else if (filtered_angle_x <-11) posTram.y = 18;
	else if (filtered_angle_x <-9) posTram.y = 17;
	else if (filtered_angle_x <-7) posTram.y = 16;
	else if (filtered_angle_x <-5) posTram.y = 15;
	else if (filtered_angle_x <-3) posTram.y = 14;
	else if (filtered_angle_x <-1) posTram.y = 13;
	else if (filtered_angle_x < 1) posTram.y = 12;
	else if (filtered_angle_x < 3) posTram.y = 11;
	else if (filtered_angle_x < 5) posTram.y = 10;
	else if (filtered_angle_x < 7) posTram.y = 9;
	else if (filtered_angle_x < 9) posTram.y = 8;
	else if (filtered_angle_x < 11) posTram.y = 7;
	else if (filtered_angle_x < 13) posTram.y = 6;
	else if (filtered_angle_x < 15) posTram.y = 5;
	else if (filtered_angle_x < 17) posTram.y = 4;
	else if (filtered_angle_x < 19) posTram.y = 3;
	else if (filtered_angle_x < 21) posTram.y = 2;
	else if (filtered_angle_x < 23) posTram.y = 1;
	else if (filtered_angle_x < 25) posTram.y = 0;
	for (int i = 0; i < LENGTH_TRAM; i++)
	{
		Image[posTram.y + offsetTram[i].y][posTram.x + offsetTram[i].x] = blue;
	}
}

// 게임 메시지 출력을 위한 알파벳 작성,..... 필요한 알파벳만 구현함
void drawA(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= bk;	Image[y-1][x] 		= c;	Image[y-2][x]	 = c;	Image[y-3][x]   	= c;	Image[y-4][x]   = bk;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = c;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = bk;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = c;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= bk;	Image[y-2][x+3]	 = bk;	Image[y-3][x+3] 	= bk;	Image[y-4][x+3] = c;
    Image[y][x+4] 	= c;	Image[y-1][x+4] 	= c;	Image[y-2][x+4]	 = c;	Image[y-3][x+4] 	= c;	Image[y-4][x+4] = c;
    Image[y][x+5] 	= c;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = c;
    Image[y][x+6] 	= c;	Image[y-1][x+6] 	= bk;	Image[y-2][x+6]	 = bk;	Image[y-3][x+6] 	= bk;	Image[y-4][x+6] = c;
}

void drawB(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= c;	Image[y-1][x] 		= c;	Image[y-2][x]	 = c;	Image[y-3][x]   	= c;	Image[y-4][x]   = bk;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = c;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = bk;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = c;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= c;	Image[y-2][x+3]	 = c;	Image[y-3][x+3] 	= c;	Image[y-4][x+3] = bk;
    Image[y][x+4] 	= c;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = bk;	Image[y-3][x+4] 	= bk;	Image[y-4][x+4] = c;
    Image[y][x+5] 	= c;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = c;
    Image[y][x+6] 	= c;	Image[y-1][x+6] 	= c;	Image[y-2][x+6]	 = c;	Image[y-3][x+6] 	= c;	Image[y-4][x+6] = bk;
}
void drawR(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= c;	Image[y-1][x] 		= c;	Image[y-2][x]	 = c;	Image[y-3][x]   	= c;	Image[y-4][x]   = bk;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = c;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = bk;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = c;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= c;	Image[y-2][x+3]	 = c;	Image[y-3][x+3] 	= c;	Image[y-4][x+3] = bk;
    Image[y][x+4] 	= c;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = c;	Image[y-3][x+4] 	= bk;	Image[y-4][x+4] = bk;
    Image[y][x+5] 	= c;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= c;	Image[y-4][x+5] = bk;
    Image[y][x+6] 	= c;	Image[y-1][x+6] 	= bk;	Image[y-2][x+6]	 = bk;	Image[y-3][x+6] 	= bk;	Image[y-4][x+6] = c;
}
void drawE(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= c;	Image[y-1][x] 		= c;	Image[y-2][x]	 = c;	Image[y-3][x]   	= c;	Image[y-4][x]   = c;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = bk;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = bk;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = bk;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= c;	Image[y-2][x+3]	 = c;	Image[y-3][x+3] 	= c;	Image[y-4][x+3] = bk;
    Image[y][x+4] 	= c;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = bk;	Image[y-3][x+4] 	= bk;	Image[y-4][x+4] = bk;
    Image[y][x+5] 	= c;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = bk;
    Image[y][x+6] 	= c;	Image[y-1][x+6] 	= c;	Image[y-2][x+6]	 = c;	Image[y-3][x+6] 	= c;	Image[y-4][x+6] = c;
}

void drawK(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= c;	Image[y-1][x] 		= bk;	Image[y-2][x]	 = bk;	Image[y-3][x]   	= bk;	Image[y-4][x]   = c;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= c;	Image[y-4][x+1] = bk;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = c;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = bk;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= c;	Image[y-2][x+3]	 = bk;	Image[y-3][x+3] 	= bk;	Image[y-4][x+3] = bk;
    Image[y][x+4] 	= c;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = c;	Image[y-3][x+4] 	= bk;	Image[y-4][x+4] = bk;
    Image[y][x+5] 	= c;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= c;	Image[y-4][x+5] = bk;
    Image[y][x+6] 	= c;	Image[y-1][x+6] 	= bk;	Image[y-2][x+6]	 = bk;	Image[y-3][x+6] 	= bk;	Image[y-4][x+6] = c;
}

void drawO(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= bk;	Image[y-1][x] 		= c;	Image[y-2][x]	 = c;	Image[y-3][x]   	= c;	Image[y-4][x]   = bk;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = c;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = bk;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = c;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= bk;	Image[y-2][x+3]	 = bk;	Image[y-3][x+3] 	= bk;	Image[y-4][x+3] = c;
    Image[y][x+4] 	= c;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = bk;	Image[y-3][x+4] 	= bk;	Image[y-4][x+4] = c;
    Image[y][x+5] 	= c;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = c;
    Image[y][x+6] 	= bk;	Image[y-1][x+6] 	= c;	Image[y-2][x+6]	 = c;	Image[y-3][x+6] 	= c;	Image[y-4][x+6] = bk;
}

void drawU(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= c;	Image[y-1][x] 		= bk;	Image[y-2][x]	 = bk;	Image[y-3][x]   	= bk;	Image[y-4][x]   = c;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = c;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = bk;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = c;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= bk;	Image[y-2][x+3]	 = bk;	Image[y-3][x+3] 	= bk;	Image[y-4][x+3] = c;
    Image[y][x+4] 	= c;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = bk;	Image[y-3][x+4] 	= bk;	Image[y-4][x+4] = c;
    Image[y][x+5] 	= c;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = c;
    Image[y][x+6] 	= bk;	Image[y-1][x+6] 	= c;	Image[y-2][x+6]	 = c;	Image[y-3][x+6] 	= c;	Image[y-4][x+6] = bk;
}

void drawT(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= c;	Image[y-1][x] 		= c;	Image[y-2][x]	 = c;	Image[y-3][x]   	= c;	Image[y-4][x]   = c;
    Image[y][x+1] 	= bk;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = c;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = bk;
    Image[y][x+2] 	= bk;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = c;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = bk;
    Image[y][x+3] 	= bk;	Image[y-1][x+3] 	= bk;	Image[y-2][x+3]	 = c;	Image[y-3][x+3] 	= bk;	Image[y-4][x+3] = bk;
    Image[y][x+4] 	= bk;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = c;	Image[y-3][x+4] 	= bk;	Image[y-4][x+4] = bk;
    Image[y][x+5] 	= bk;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = c;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = bk;
    Image[y][x+6] 	= bk;	Image[y-1][x+6] 	= bk;	Image[y-2][x+6]	 = c;	Image[y-3][x+6] 	= bk;	Image[y-4][x+6] = bk;
}
void drawG(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= bk;	Image[y-1][x] 		= c;	Image[y-2][x]	 = c;	Image[y-3][x]   	= c;	Image[y-4][x]   = bk;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = c;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = bk;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = bk;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= bk;	Image[y-2][x+3]	 = bk;	Image[y-3][x+3] 	= bk;	Image[y-4][x+3] = bk;
    Image[y][x+4] 	= c;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = bk;	Image[y-3][x+4] 	= c;	Image[y-4][x+4] = c;
    Image[y][x+5] 	= c;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = c;
    Image[y][x+6] 	= bk;	Image[y-1][x+6] 	= c;	Image[y-2][x+6]	 = c;	Image[y-3][x+6] 	= c;	Image[y-4][x+6] = bk;
}

void drawM(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= c;	Image[y-1][x] 		= bk;	Image[y-2][x]	 = bk;	Image[y-3][x]   	= bk;	Image[y-4][x]   = c;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= c;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= c;	Image[y-4][x+1] = c;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = c;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = c;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= bk;	Image[y-2][x+3]	 = c;	Image[y-3][x+3] 	= bk;	Image[y-4][x+3] = c;
    Image[y][x+4] 	= c;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = bk;	Image[y-3][x+4] 	= bk;	Image[y-4][x+4] = c;
    Image[y][x+5] 	= c;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = c;
    Image[y][x+6] 	= c;	Image[y-1][x+6] 	= bk;	Image[y-2][x+6]	 = bk;	Image[y-3][x+6] 	= bk;	Image[y-4][x+6] = c;
}
void drawV(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= c;	Image[y-1][x] 		= bk;	Image[y-2][x]	 = bk;	Image[y-3][x]   	= bk;	Image[y-4][x]   = c;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = c;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = bk;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = c;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= bk;	Image[y-2][x+3]	 = bk;	Image[y-3][x+3] 	= bk;	Image[y-4][x+3] = c;
    Image[y][x+4] 	= bk;	Image[y-1][x+4] 	= c;	Image[y-2][x+4]	 = bk;	Image[y-3][x+4] 	= c;	Image[y-4][x+4] = bk;
    Image[y][x+5] 	= bk;	Image[y-1][x+5] 	= c;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= c;	Image[y-4][x+5] = bk;
    Image[y][x+6] 	= bk;	Image[y-1][x+6] 	= bk;	Image[y-2][x+6]	 = c;	Image[y-3][x+6] 	= bk;	Image[y-4][x+6] = bk;
}

void drawW(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= c;	Image[y-1][x] 		= bk;	Image[y-2][x]	 = bk;	Image[y-3][x]   	= bk;	Image[y-4][x]   = c;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = c;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = bk;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = c;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= bk;	Image[y-2][x+3]	 = c;	Image[y-3][x+3] 	= bk;	Image[y-4][x+3] = c;
    Image[y][x+4] 	= c;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = c;	Image[y-3][x+4] 	= bk;	Image[y-4][x+4] = c;
    Image[y][x+5] 	= c;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = c;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = c;
    Image[y][x+6] 	= bk;	Image[y-1][x+6] 	= c;	Image[y-2][x+6]	 = bk;	Image[y-3][x+6] 	= c;	Image[y-4][x+6] = bk;
}

void drawI(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= bk;	Image[y-1][x] 		= c;	Image[y-2][x]	 = c;	Image[y-3][x]   	= c;	Image[y-4][x]   = bk;
    Image[y][x+1] 	= bk;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = c;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = bk;
    Image[y][x+2] 	= bk;	Image[y-1][x+2] 	= bk;	Image[y-2][x+2]	 = c;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = bk;
    Image[y][x+3] 	= bk;	Image[y-1][x+3] 	= bk;	Image[y-2][x+3]	 = c;	Image[y-3][x+3] 	= bk;	Image[y-4][x+3] = bk;
    Image[y][x+4] 	= bk;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = c;	Image[y-3][x+4] 	= bk;	Image[y-4][x+4] = bk;
    Image[y][x+5] 	= bk;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = c;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = bk;
    Image[y][x+6] 	= bk;	Image[y-1][x+6] 	= c;	Image[y-2][x+6]	 = c;	Image[y-3][x+6] 	= c;	Image[y-4][x+6] = bk;
}

void drawN(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= c;	Image[y-1][x] 		= bk;	Image[y-2][x]	 = bk;	Image[y-3][x]   	= bk;	Image[y-4][x]   = c;
    Image[y][x+1] 	= c;	Image[y-1][x+1] 	= bk;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= bk;	Image[y-4][x+1] = c;
    Image[y][x+2] 	= c;	Image[y-1][x+2] 	= c;	Image[y-2][x+2]	 = bk;	Image[y-3][x+2] 	= bk;	Image[y-4][x+2] = c;
    Image[y][x+3] 	= c;	Image[y-1][x+3] 	= bk;	Image[y-2][x+3]	 = c;	Image[y-3][x+3] 	= bk;	Image[y-4][x+3] = c;
    Image[y][x+4] 	= c;	Image[y-1][x+4] 	= bk;	Image[y-2][x+4]	 = bk;	Image[y-3][x+4] 	= c;	Image[y-4][x+4] = c;
    Image[y][x+5] 	= c;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = c;
    Image[y][x+6] 	= c;	Image[y-1][x+6] 	= bk;	Image[y-2][x+6]	 = bk;	Image[y-3][x+6] 	= bk;	Image[y-4][x+6] = c;
}

// !! 출력
void drawMARK1(Color c, int x, int y)
{
	if (y < 4) return;
	if (x > 57) return;
	Image[y][x] 	= bk;	Image[y-1][x] 		= c;	Image[y-2][x]	 = bk;	Image[y-3][x]   	= c;	Image[y-4][x]   = bk;
    Image[y][x+1] 	= bk;	Image[y-1][x+1] 	= c;	Image[y-2][x+1]	 = bk;	Image[y-3][x+1] 	= c;	Image[y-4][x+1] = bk;
    Image[y][x+2] 	= bk;	Image[y-1][x+2] 	= c;	Image[y-2][x+2]	 = bk;	Image[y-3][x+2] 	= c;	Image[y-4][x+2] = bk;
    Image[y][x+3] 	= bk;	Image[y-1][x+3] 	= c;	Image[y-2][x+3]	 = bk;	Image[y-3][x+3] 	= c;	Image[y-4][x+3] = bk;
    Image[y][x+4] 	= bk;	Image[y-1][x+4] 	= c;	Image[y-2][x+4]	 = bk;	Image[y-3][x+4] 	= c;	Image[y-4][x+4] = bk;
    Image[y][x+5] 	= bk;	Image[y-1][x+5] 	= bk;	Image[y-2][x+5]	 = bk;	Image[y-3][x+5] 	= bk;	Image[y-4][x+5] = bk;
    Image[y][x+6] 	= bk;	Image[y-1][x+6] 	= c;	Image[y-2][x+6]	 = bk;	Image[y-3][x+6] 	= c;	Image[y-4][x+6] = bk;
}


// 원하는 좌표의 원하는 크기의 직사각형 출력
void drawRectangle(Color c, int x, int x_, int y, int y_)
{
	for (int i = x; i <= x_; i++)
	{
		for (int j = y; j <= y_; j++)
		{
			Image[j][i] = c;
		}
	}
}

// 화면에 게임 제목 출력
// 게임 제목은 BREAK OUT -> 오리지널 벽돌깨기 게임의 제목이라고 함
void goStartPage()
{
	int offset_x = 25;

	drawRectangle(yellow, 20,21,0, 31);
	drawRectangle(green, 43,44,0, 31);

	drawB(red, 0 + offset_x, 30);
	drawR(red, 0 + offset_x, 24);
	drawE(red, 0 + offset_x, 18);
	drawA(red, 0 + offset_x, 12);
	drawK(red, 0 + offset_x, 6);

	drawO(red, 8 + offset_x, 24);
	drawU(red, 8 + offset_x, 18);
	drawT(red, 8 + offset_x, 12);
}

// 화면에 게임 종료 출력
void goEndPage()
{

	int offset_x = 25;

	drawRectangle(yellow, 20,21,0, 31);
	drawRectangle(green, 43,44,0, 31);

	drawG(red, 0 + offset_x, 30);
	drawA(red, 0 + offset_x, 24);
	drawM(red, 0 + offset_x, 18);
	drawE(red, 0 + offset_x, 12);

	drawO(red, 8 + offset_x, 24);
	drawV(red, 8 + offset_x, 18);
	drawE(red, 8 + offset_x, 12);
	drawR(red, 8 + offset_x, 6);
}


// 화면에 게임 승리 출력
void goWinPage()
{

	int offset_x = 25;
	int offset_y = -6;

	drawRectangle(yellow, 20,21,0, 31);
	drawRectangle(green, 36,37,0, 31);

	drawW(purple, 0 + offset_x, 30 + offset_y);
	drawI(purple, 0 + offset_x, 24 + offset_y);
	drawN(purple, 0 + offset_x, 18 + offset_y);
	drawMARK1(purple, 0 + offset_x, 12 + offset_y);
}


// 현제 게임 진행상황(블럭이 깨진 정도)를 체크하여 게임 진행 속도 올림 ->게임이 진행될 수록 난이도 상승
void checkSpeed()
{
	int sum = 0;
	for (int i = 0; i< COUNT_BRICK1; i++)
	{
		sum += flagBrick1[i];
	}
	for (int i = 0; i< COUNT_BRICK2; i++)
	{
		sum += flagBrick2[i];
	}
	if (sum == 0) gameState = 3;
	else if (sum < 5 ) TIM2->PSC = BASEPRESCALER - 4800*6;
	else if (sum < 10 ) TIM2->PSC = BASEPRESCALER - 4800*5;
	else if (sum < 14 ) TIM2->PSC = BASEPRESCALER - 4800*3;
	else if (sum < 18 ) TIM2->PSC = BASEPRESCALER - 4800*1;
}

// 왼쪽 버튼 2개 callback
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  if (GPIO_Pin == GPIO_PIN_14)	// 위쪽 버튼, 버튼 1
  {
	  initializeGame();
	  gameState = 1;	// start game
  }
  else if (GPIO_Pin == GPIO_PIN_15)	// 아래쪽 버튼, 버튼 2
  {
	  initializeGame();
	  gameState = 0;	// end game
  }
}

// 게임 진행을 위한 타이머
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	// run game
	if (htim->Instance == TIM2)
	{
		if (gameState == 0)	// 게임 시작 페이지
		{
			goStartPage();
		}
		else if(gameState == 1)	// 게임 플레이
		{
			checkSpeed();
			drawBrick();
			drawBall();
		}
		else if(gameState == 2)	// 게임 패배
		{
			goEndPage();
		}
		else if(gameState == 3)	// 게임 승리
		{
			goWinPage();
		}
	}
	// run LED MATRIX
	else if (htim->Instance == TIM3)
	{
		showDisplay();
		// 발판 움직이는 속도가 게임 진행 속도에 영향을 받지 않는다.
		drawTram();
	}
}

// MPU6050값 파싱
void CalcAccelYPR();
void CalcGyroYPR();
void CalcFilteredYPR();
void CalibAccelGyro();

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */
  

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  /* USER CODE BEGIN 2 */
  MPU6050_Init(0x06);

  CalibAccelGyro();

  HAL_TIM_Base_Start_IT(&htim2);
  HAL_TIM_Base_Start_IT(&htim3);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  // MPU6050 값 가져오는 함수
	  MPU6050_GetData(&ax, &ay, &az, &gx, &gy, &gz, &tmpr);
	  CalcAccelYPR();
	  CalcGyroYPR();
	  CalcFilteredYPR();
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */
void CalibAccelGyro()
{
	float SumAcc_x = 0;
	float SumAcc_y = 0;
	float SumAcc_z = 0;
	float SumGyro_x = 0;
	float SumGyro_y = 0;
	float SumGyro_z = 0;

	for (int i = 0; i < 10; i++)
	{
		MPU6050_GetData(&ax, &ay, &az, &gx, &gy, &gz, &tmpr);

		SumAcc_x += ax, SumAcc_y += ay, SumAcc_z += az;
		SumGyro_x += gx, SumGyro_y += gy, SumGyro_z += gz;
		HAL_Delay(100);
	}

	baseAcc_x = SumAcc_x / 10;
	baseAcc_y = SumAcc_y / 10;
	baseAcc_z = SumAcc_z / 10;
	baseGyro_x = SumGyro_x / 10;
	baseGyro_y = SumGyro_y / 10;
	baseGyro_z = SumGyro_z / 10;
}

void CalcAccelYPR()
{
	const float RADIANS_TO_DEGREES = 180 / 3.14159;

	accel_x = ax - baseAcc_x;
	accel_y = ay - baseAcc_y;
	accel_z = az + (16384 - baseAcc_z);

	//accel_angle_y = roll
	accel_yz = sqrt(pow(accel_y, 2) + pow(accel_z, 2));
	accel_angle_y = atan(-accel_x / accel_yz) * RADIANS_TO_DEGREES;

	//accel_angle_x = pitch
	accel_xz = sqrt(pow(accel_x, 2) + pow(accel_z, 2));
	accel_angle_x = atan(accel_y / accel_xz) * RADIANS_TO_DEGREES;

	accel_angle_z = 0; //
}

void CalcGyroYPR()
{
	const float GYROXYZ_TO_DEGREES_PER_SEC = 131;

	gyro_x = (gx - baseGyro_x) / GYROXYZ_TO_DEGREES_PER_SEC;
	gyro_y = (gy - baseGyro_y) / GYROXYZ_TO_DEGREES_PER_SEC;
	gyro_z = (gz - baseGyro_z) / GYROXYZ_TO_DEGREES_PER_SEC;

	gyro_angle_x += gyro_x * dt;
	gyro_angle_y += gyro_y * dt;
	gyro_angle_z += gyro_z * dt;
}

void CalcFilteredYPR()
{
	const float ALPHA = 0.96;

	tmp_angle_x = filtered_angle_x + gyro_x * dt;
	tmp_angle_y = filtered_angle_y + gyro_y * dt;
	tmp_angle_z = filtered_angle_z + gyro_z * dt;

	filtered_angle_x = ALPHA * tmp_angle_x + (1.0 - ALPHA) * accel_angle_x;
	filtered_angle_y = ALPHA * tmp_angle_y + (1.0 - ALPHA) * accel_angle_y;
	filtered_angle_z = tmp_angle_z;
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
